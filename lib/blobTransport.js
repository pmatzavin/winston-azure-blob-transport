"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.3.2
(function () {
  var BlobTransport,
      MAX_BLOCK_SIZE,
      Promise,
      Transport,
      _,
      async,
      azure,
      chunk,
      debug,
      errorToJson,
      messageSymbol,
      util,
      winston,
      boundMethodCheck = function boundMethodCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new Error('Bound instance method accessed before binding');
    }
  };

  debug = require("debug")("winston-blob-transport");

  _ = require("lodash");

  util = require("util");

  errorToJson = require("error-to-json");

  azure = require("azure-storage");

  async = require("async");

  winston = require("winston");

  chunk = require("chunk");

  Promise = require("bluebird");

  Transport = winston.Transport;

  MAX_BLOCK_SIZE = azure.Constants.BlobConstants.MAX_APPEND_BLOB_BLOCK_SIZE;

  messageSymbol = Symbol.for("message");

  BlobTransport = function (_Transport) {
    _inherits(BlobTransport, _Transport);

    function BlobTransport(_ref) {
      var account = _ref.account,
          containerName = _ref.containerName,
          blobName = _ref.blobName,
          _ref$level = _ref.level,
          level1 = _ref$level === undefined ? "info" : _ref$level,
          nameResolver = _ref.nameResolver;

      _classCallCheck(this, BlobTransport);

      var _this = _possibleConstructorReturn(this, (BlobTransport.__proto__ || Object.getPrototypeOf(BlobTransport)).call(this));

      _this.log = _this.log.bind(_this);
      _this._buildCargo = _this._buildCargo.bind(_this);
      _this._retryIfNecessary = _this._retryIfNecessary.bind(_this);
      _this._formatLine = _this._formatLine.bind(_this);
      _this._meta = _this._meta.bind(_this);
      _this._buildClient = _this._buildClient.bind(_this);
      _this.account = account;
      _this.containerName = containerName;
      _this.blobName = blobName;
      _this.level = level1;
      _this.nameResolver = nameResolver;
      _this.name = "BlobTransport";
      _this.cargo = _this._buildCargo();
      _this.client = _this._buildClient(_this.account);
      if (_this.nameResolver == null) {
        _this.nameResolver = {
          getBlobName: function getBlobName() {
            return _this.blobName;
          }
        };
      }
      return _this;
    }

    _createClass(BlobTransport, [{
      key: "initialize",
      value: function initialize() {
        var _this2 = this;

        var connectionString;
        connectionString = "DefaultEndpointsProtocol=https;AccountName=" + this.account.name + ";AccountKey=" + this.account.key;
        return Promise.promisifyAll(azure.createBlobService(connectionString)).createContainerIfNotExistsAsync(this.containerName, {
          publicAccessLevel: "blob"
        }).then(function (created) {
          return debug("Container: " + _this2.container + " - " + (created ? 'created' : 'already exist'));
        });
      }
    }, {
      key: "log",
      value: function log(level, msg, meta, callback) {
        var line;
        boundMethodCheck(this, BlobTransport);
        line = this._formatLine({ level: level, msg: msg, meta: meta });
        this.cargo.push({ line: line, callback: callback });
      }
    }, {
      key: "_buildCargo",
      value: function _buildCargo() {
        var _this3 = this;

        boundMethodCheck(this, BlobTransport);
        return async.cargo(function (tasks, __whenFinishCargo) {
          var __whenLogAllBlock, chunks, logBlock;
          __whenLogAllBlock = function __whenLogAllBlock() {
            debug("Finish append all lines to blob");
            _.each(tasks, function (_ref2) {
              var callback = _ref2.callback;

              return callback(null, true);
            });
            return __whenFinishCargo();
          };
          debug("Log " + tasks.length + "th lines");
          logBlock = _.map(tasks, "line").join("");
          debug("Starting append log lines to blob. Size " + logBlock.length);
          chunks = chunk(logBlock, MAX_BLOCK_SIZE);
          debug("Saving " + chunks.length + " chunk(s)");
          return async.eachSeries(chunks, function (chunk, whenLoggedChunk) {
            debug("Saving log with size " + chunk.length);
            return _this3.client.appendFromText(_this3.containerName, _this3.nameResolver.getBlobName(), chunk, function (err, result) {
              if (err) {
                return _this3._retryIfNecessary(err, chunk, whenLoggedChunk);
              }
              return whenLoggedChunk();
            });
          }, function (err) {
            if (err) {
              debug("Error in block");
            }
            return __whenLogAllBlock();
          });
        });
      }
    }, {
      key: "_retryIfNecessary",
      value: function _retryIfNecessary(err, block, whenLoggedChunk) {
        var _this4 = this;

        var __createAndAppend, __doesNotExistFile, __handle;
        boundMethodCheck(this, BlobTransport);
        __createAndAppend = function __createAndAppend() {
          return _this4.client.createAppendBlobFromText(_this4.containerName, _this4.nameResolver.getBlobName(), block, {}, __handle);
        };
        __doesNotExistFile = function __doesNotExistFile() {
          return err.code != null && err.code === "NotFound";
        };
        __handle = function __handle(err) {
          if (err) {
            debug("Error in append", err);
          }
          return whenLoggedChunk();
        };
        if (__doesNotExistFile()) {
          return __createAndAppend();
        } else {
          return __handle(err);
        }
      }
    }, {
      key: "_formatLine",
      value: function _formatLine(_ref3) {
        var level = _ref3.level,
            msg = _ref3.msg,
            meta = _ref3.meta;

        boundMethodCheck(this, BlobTransport);
        return this._meta[messageSymbol];
      }
    }, {
      key: "_timestamp",
      value: function _timestamp() {
        return new Date().toISOString();
      }
    }, {
      key: "_meta",
      value: function _meta(meta) {
        boundMethodCheck(this, BlobTransport);
        if (meta instanceof Error) {
          meta = errorToJson(meta);
        }
        if (_.isEmpty(meta)) {
          return "";
        } else {
          return "- " + util.inspect(meta);
        }
      }
    }, {
      key: "_buildClient",
      value: function _buildClient(_ref4) {
        var name = _ref4.name,
            key = _ref4.key;

        boundMethodCheck(this, BlobTransport);
        return azure.createBlobService(name, key);
      }
    }]);

    return BlobTransport;
  }(Transport);

  // Define a getter so that `winston.transports.AzureBlob`
  // is available and thus backwards compatible.

  winston.transports.AzureBlob = BlobTransport;

  module.exports = BlobTransport;
}).call(undefined);